Lets use this file to record notes about the package, questions, and stuff we decide while working on it. 

Need to establish convention for conversion of discrete time to continuous.  Does a wave imply the spell a) 1.0-1.0 or b) 1.0-2.0.  Skye votes for a, but it is not currently compatible with network.extract or is.active
CARTER votes  b)

Assuming we use b above, when we have a series of exactly adjacent spells with the same values, should they be merged into a single spell to save space?  Always? Never? Add a compression method for post processing cleanup?

Proposal: network.optimize method that can be called after network construction to reduce things to optimal form. 

NetworkDynamic Methods that need to be modified when we include TEA:

network.extract
%t%

Problem: asking for a crosssection aggregating over an interval (both onset and termination time included) means that we need to specify how any possibly conflicting TEAs should be aggregated, and we need to be able to pass this through the network.extract call.  Maybe use the rule argument?

Proposal: Its really hard, and for most examples we just need the momentary crosssection, so just implement just the momentary version and throw errors for the cases where aggregation is required. 

What should happen to dynamic attributes in the network returned by network.extract?
Proposal: they should be made non-dynamic with the appropriate values. Con: possible colision with non-dynamic vars of the same name.

network.dynamic.check
Proposal: extend check spell matrix ordering and integrity for attributes, and that attributes are not active when attached nodes and edges are inactive. 

Proposal:  rename the network.series object to network.samples  (appears in .paj file reader, output of ergm.simulate, perhaps used internally by gof ?), ask Pavel?  In some cases it is network + toggles? 



New utility methods.

as.tel() convert dynamic network to timed edge list
as.tvl() convert dynamic network to timed vertex list
as.network.series(dynamic.network, interval, start, end,aggregate.dur=NULL, aggregate.rule,)  convert dynamic network into a series of "slice" networks by calling network.extract

start :: when to start the slicing, default to min observed in network
end :: when to stop the slicing, default to max observed. 
interval :: where / how far apart to take the slices  interval=NULL: every wave (if discrete case) every change (if continuous), interval=value:  every value-th time point, interval=c(1,2,3): at times 1,2,3
aggregate.dur :: duration (thickness) of time slice  NULL : onset = termination
aggregate.rule = how to handle merging of edge weights and attributes (magic, not yet implemented)




as.network.dynamic.tel()  convert timed edge list to dynamic network, in the future extend to include attributes
as.network.dynamic.panel()  take a list of networks assumed to be panel observations and make a dynamic network object.  Assume separate panels, don't link sequential intervals. Maybe provide option to link intervals in the future?
as.network.dynamic.toggles() take an initial network and lists of changes list 

need an activate.edge(x,head,tail,onset,term) method







DATA SETS
It will be really helpful to have some example data sets with dynamic elements and attributes to use for testing and docs. Proposals:

Botswana networkDynamic objects generated by Nicole (500 to 10k nodes, 1000 times steps) with somewhat realistic generated attributes.

Faux High Dynamic ("Glee")   dynamic version of Faux high, changing friendships, made up attributes, nodes enter and exit, sing musical numbers.  Create by randomly perturb start and end dates to make it dynamic (this will also reduce the density).

McFarland classrooms (small networks, streaming event data, changing edges)? Does carter have an example dataset for relevant?

Newcomb  panel data 14 waves.  Nice example for converting panel to networkDynamic, since most people have that


Steve examples?  generating something on the fly from STERGM?

Does Mark have examples of missing data that we should include?

Flo marriage  (nice and small, possible to look at it directly when testing or debugging) 

Why are networks with 0 vertices prohibited? seems like we need them if all vertices can become inactive
network.initialize(0)
Error in network.initialize(0) : 
  Network objects must have at least one vertex.

Shouldn't network.extract return a network of the same size as the original network, instead of only the active nodes?
Proposal: add a flag to let it do that

Proposal network.collapse should (optionally) collapse any temporal attributes of networks, vertices and edges when it is slicing the networks. This should be controlled by a flag, because it could cause collisions with same-named attributes. 

Additional spell inclusion rules. Currently we support "any" and "all".  Ayn has a good argument that we may want a "majority" (active 50% or more) rule, Skye would like an "all-or-ending" rule that includes spells ending within the query spell or continuing throughout but excludes those starting within.  The purpose of the rule is to prevent double-counting of elements spanning sequential query spells caused by "any" rule.  Ayn also proposes allowing passing in an arbitrary function.  Concerns about performance and complexity.  



